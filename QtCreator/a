import sys
import serial
import time
import datetime
from collections import deque
from PyQt6.QtWidgets import (
    QApplication, QLabel, QVBoxLayout, QWidget, QMainWindow,
    QPushButton, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import QTimer, Qt, QThread, pyqtSignal
from PyQt6.QtGui import QFont
import pyqtgraph as pg

from report_generator import ReportGenerator

# Worker para lectura serial en hilo separado
class SerialReader(QThread):
    data_received = pyqtSignal(float, float, float)  # shunt_mv, voltage, current

    def __init__(self, port_name='COM3', baudrate=115200):
        super().__init__()
        self.port_name = port_name
        self.baudrate = baudrate
        self.ser = None
        self.running = True

    def run(self):
        while self.running:
            try:
                if not self.ser:
                    self.ser = serial.Serial(self.port_name, self.baudrate, timeout=5)
                    self.ser.reset_input_buffer()
                    print(f"Conectado a {self.port_name}")

                if self.ser.in_waiting > 0:
                    line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                    parts = line.split(",")
                    if len(parts) == 3:
                        shunt_mv, voltage, current = map(float, parts)
                        self.data_received.emit(shunt_mv, voltage, current)

            except Exception as e:
                print("Error leyendo serial:", e)
                time.sleep(1)  # evitar bucle muy rápido si falla

    def stop(self):
        self.running = False
        if self.ser and self.ser.is_open:
            self.ser.close()
        self.quit()
        self.wait()


class SensorApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Monitoreo de Energía")
        self.setStyleSheet("background-color: #FAFAFA; color: #212121;")

        self.init_fonts()
        self.init_ui()

        # Variables de integración
        self.energy_joules = 0.0
        self.sample_index = 0
        self.total_samples = 0
        self.start_time = time.time()
        self.last_time = self.start_time

        # Reporte
        self.report = ReportGenerator()

        # Checkpoints (1m, 10m, 30m, 1h, 2h, 4h, 8h, 16h, 24h)
        self.checkpoints = [60, 600, 1800, 3600, 7200, 14400, 28800, 57600, 86400]
        self.checkpoints_reached = set()
        self.test_records = []

        # Buffers para gráficas
        self.voltage_data = deque(maxlen=300)
        self.current_data = deque(maxlen=300)

        # Iniciar hilo de lectura serial
        self.serial_thread = SerialReader(port_name='COM3', baudrate=115200)
        self.serial_thread.data_received.connect(self.update_data)
        self.serial_thread.start()

        # Timer para refrescar gráficas
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plots)
        self.timer.start(100)  # 10 Hz

    def init_fonts(self):
        self.font_large = QFont("Segoe UI", 36, QFont.Weight.Bold)
        self.font_small = QFont("Segoe UI", 14)

    def init_ui(self):
        self.voltage_label = self.create_label("0.000000 V", self.font_large, "#388E3C")
        self.current_label = self.create_label("0.000000 A", self.font_large, "#1976D2")

        data_layout = QHBoxLayout()
        data_layout.addWidget(self.voltage_label)
        data_layout.addWidget(self.current_label)

        self.voltage_plot = self.create_plot("Voltaje (V)", '#388E3C', y_range=(0, 4))
        self.current_plot = self.create_plot("Corriente (A)", '#1976D2', y_range=(-0.03, 0.1))

        self.time_label = self.create_label("Tiempo: 00:00:00", self.font_small, "#555555")
        self.energy_label = self.create_label("Energía: 0.0000 J", self.font_small, "#0097A7")
        self.energy_wh_label = self.create_label("Acumulado: 0.0000 mWh", self.font_small, "#0097A7")

        bottom_layout = QHBoxLayout()
        bottom_layout.setSpacing(16)
        bottom_layout.addWidget(self.time_label, stretch=1)
        bottom_layout.addWidget(self.energy_label, stretch=1)
        bottom_layout.addWidget(self.energy_wh_label, stretch=1)

        self.report_button = QPushButton("Registrar")
        self.report_button.setFont(self.font_small)
        self.report_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.report_button.setFixedSize(200, 36)
        self.report_button.setStyleSheet("""
            QPushButton {
                background-color: #0097A7;
                border-radius: 12px;
                color: white;
                font-weight: 600;
            }
            QPushButton:hover { background-color: #007C91; }
            QPushButton:pressed { background-color: #005F6B; }
        """)
        self.report_button.clicked.connect(self.generate_report)

        buttons_layout = QHBoxLayout()
        buttons_layout.addWidget(self.report_button)
        buttons_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(25, 25, 25, 25)
        main_layout.setSpacing(20)
        main_layout.addLayout(data_layout)
        main_layout.addWidget(self.voltage_plot, stretch=3)
        main_layout.addWidget(self.current_plot, stretch=3)
        main_layout.addLayout(bottom_layout)
        main_layout.addLayout(buttons_layout)

        container = QWidget()
        container.setLayout(main_layout)
        self.setCentralWidget(container)

    def create_label(self, text, font, color):
        label = QLabel(text)
        label.setFont(font)
        label.setStyleSheet(f"color: {color};")
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        return label

    def create_plot(self, ylabel, color, y_range):
        plot = pg.PlotWidget()
        plot.setBackground('w')
        plot.showGrid(x=True, y=True, alpha=0.3)
        plot.setLabel('left', ylabel, color='#444444', size='14pt')
        plot.setLabel('bottom', '', color='#444444', size='14pt')
        plot.setYRange(*y_range)
        plot.setXRange(0, 200)
        curve = plot.plot(pen=pg.mkPen(color, width=1))
        plot.curve = curve
        return plot

    def update_data(self, shunt_mv, voltage, current):
        current_time = time.time()
        dt = current_time - self.last_time
        if dt <= 0:
            dt = 0.0001
        self.last_time = current_time

        # Energía
        power = voltage * current
        self.energy_joules += power * dt
        energy_mwh = (self.energy_joules / 3600.0) * 1000.0

        # Etiquetas
        self.voltage_label.setText(f"{voltage:.6f} V")
        self.current_label.setText(f"{current:.6f} A")
        self.energy_label.setText(f"Energía: {self.energy_joules:.4f} J")
        self.energy_wh_label.setText(f"Acumulado: {energy_mwh:.4f} mWh")

        # Buffers para gráficas
        self.voltage_data.append(voltage)
        self.current_data.append(current)

        # Contadores
        self.sample_index += 1
        self.total_samples += 1

        # Tiempo transcurrido
        elapsed_seconds = current_time - self.start_time
        self.time_label.setText(f"Tiempo: {self.format_time(elapsed_seconds)}")

        # Guardar checkpoints
        for cp in self.checkpoints:
            if elapsed_seconds >= cp and cp not in self.checkpoints_reached:
                registro = {
                    "fecha_hora": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "tiempo_segundos": elapsed_seconds,
                    "voltage": voltage,
                    "corriente_min": min(self.current_data) if self.current_data else 0.0,
                    "corriente_max": max(self.current_data) if self.current_data else 0.0,
                    "corriente_prom": (sum(self.current_data)/len(self.current_data)) if self.current_data else 0.0,
                    "energia_mwh": energy_mwh,
                    "num_muestras": self.total_samples,
                }
                self.test_records.append(registro)
                self.checkpoints_reached.add(cp)
                print(f"Checkpoint guardado: {registro}")

    def update_plots(self):
        n = len(self.voltage_data)
        x_start = max(0, self.sample_index - n + 1)
        x = list(range(x_start, x_start + n))
        self.voltage_plot.curve.setData(x, list(self.voltage_data))
        self.current_plot.curve.setData(x, list(self.current_data))
        if self.sample_index > 190:
            self.voltage_plot.setXRange(self.sample_index - 190, self.sample_index)
            self.current_plot.setXRange(self.sample_index - 190, self.sample_index)

    def format_time(self, seconds):
        hrs = int(seconds // 3600)
        mins = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        return f"{hrs:02d}:{mins:02d}:{secs:02d}"

    def generate_report(self):
        self.report.set_summary(test_records=self.test_records)
        self.report.generate_pdf("consumo_energia_resumen.pdf")
        QMessageBox.information(self, "Reporte", "Reporte generado correctamente.")

    def closeEvent(self, event):
        self.serial_thread.stop()
        super().closeEvent(event)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = SensorApp()
    window.resize(900, 600)
    window.show()
    sys.exit(app.exec())
